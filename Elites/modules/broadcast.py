from pyrogram.types import Message
from pyrogram import filters, Client, errors, enums
from pyrogram.errors.exceptions.flood_420 import FloodWait
import random, asyncio
from Elites import Elites as app
from pymongo import MongoClient
from config import MONGO_URI,OWNER_ID

client = MongoClient(MONGO_URI)

users = client['main']['users']
groups = client['main']['groups']

def already_db(user_id):
        user = users.find_one({"user_id" : str(user_id)})
        if not user:
            return False
        return True

def already_dbg(chat_id):
        group = groups.find_one({"chat_id" : str(chat_id)})
        if not group:
            return False
        return True

def add_user(user_id):
    in_db = already_db(user_id)
    if in_db:
        return
    return users.insert_one({"user_id": str(user_id)}) 

def remove_user(user_id):
    in_db = already_db(user_id)
    if not in_db:
        return 
    return users.delete_one({"user_id": str(user_id)})
    
def add_group(chat_id):
    in_db = already_dbg(chat_id)
    if in_db:
        return
    return groups.insert_one({"chat_id": str(chat_id)})

def all_users():
    user = users.find({})
    usrs = len(list(user))
    return usrs

def all_groups():
    group = groups.find({})
    grps = len(list(group))
    return grps

@app.on_message(filters.command("broadcast") & filters.user(OWNER_ID))
async def bcast(_, m : Message):
    allusers = users
    lel = await m.reply_text("`‚ö°Ô∏è Processing...`")
    success = 0
    failed = 0
    deactivated = 0
    blocked = 0
    for usrs in allusers.find():
        try:
            userid = usrs["user_id"]
            #print(int(userid))
            if m.command[0] == "broadcast":
                await m.reply_to_message.copy(int(userid))
            success +=1
        except FloodWait as ex:
            await asyncio.sleep(ex.value)
            if m.command[0] == "broadcast":
                await m.reply_to_message.copy(int(userid))
        except errors.InputUserDeactivated:
            deactivated +=1
            remove_user(userid)
        except errors.UserIsBlocked:
            blocked +=1
        except Exception as e:
            print(e)
            failed +=1

    await lel.edit(f"‚úÖSuccessfull to `{success}` users.\n‚ùå Faild to `{failed}` users.\nüëæ Found `{blocked}` Blocked users \nüëª Found `{deactivated}` Deactivated users.")


@app.on_message(filters.command("fcast") & filters.user(OWNER_ID))
async def fcast(_, m : Message):
    allusers = users
    lel = await m.reply_text("`‚ö°Ô∏è Processing...`")
    success = 0
    failed = 0
    deactivated = 0
    blocked = 0
    for usrs in allusers.find():
        try:
            userid = usrs["user_id"]
            #print(int(userid))
            if m.command[0] == "fcast":
                await m.reply_to_message.forward(int(userid))
            success +=1
        except FloodWait as ex:
            await asyncio.sleep(ex.value)
            if m.command[0] == "fcast":
                await m.reply_to_message.forward(int(userid))
        except errors.InputUserDeactivated:
            deactivated +=1
            remove_user(userid)
        except errors.UserIsBlocked:
            blocked +=1
        except Exception as e:
            print(e)
            failed +=1

    await lel.edit(f"‚úÖSuccessfull to `{success}` users.\n‚ùå Faild to `{failed}` users.\nüëæ Found `{blocked}` Blocked users \nüëª Found `{deactivated}` Deactivated users.")
          
@app.on_message(filters.command("users") & filters.user(OWNER_ID))
async def dbtool(_, m : Message):
    xx = all_users()
    x = all_groups()
    tot = int(xx + x)
    await m.reply_text(text=f"""
 ‚òÖ Us·¥á Äs : `{xx}`
 ‚òÖ G Ä·¥è·¥ú·¥òs : `{x}`
 ‚òÖ T·¥è·¥õ·¥Ä ü ·¥ús·¥á Äs & …¢ Ä·¥è·¥ú·¥òs : `{tot}` """)
        
